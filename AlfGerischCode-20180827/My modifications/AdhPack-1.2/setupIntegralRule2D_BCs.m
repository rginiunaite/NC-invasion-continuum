function nonlocalBCs = setupIntegralRule2D_BCs(nonlocal, N1, N2, ...
							 BCs)
% N1        ... number of grid points (cells) in x1 direction
% N2        ... number of grid points (cells) in x2 direction


% Vx1FFT, Vx2FFT            ... structures to evaluate the
%                               non-local term using FFT
%                               techniques, see evalIntegral2D.m

% List of subfunctions in this file
% ==========================================
% function ret = setupMvFFT(W, N1, N2, lm, km)

nonlocalBCs = nonlocal;
nonlocalBCs.N1 = N1;
nonlocalBCs.N2 = N2;


switch BCs
 case 'pp'
  nonlocalBCs.Vx1FFT = setupMvFFT(nonlocal.Wx1, N1, N2, ...
					     nonlocal.lm, nonlocal.km); 
  nonlocalBCs.Vx2FFT = setupMvFFT(nonlocal.Wx2, N1, N2, ...
					     nonlocal.lm, nonlocal.km); ...
 case {'pppp', 'zzzz'}
  % dimensions of weight matrix
  z = nonlocal.km+1+nonlocal.kp; % rows
  s = nonlocal.lm+1+nonlocal.lp; % columns
  switch nonlocal.dir
   case 'x1'
    % dimensions of result matrix A
    A_z = N2;   % rows
    A_s = N1+1; % columns
    % dimensions of extended G matrix
    Gext_z = N2+z-1;
    Gext_s = N1+s;
   case 'x2'
    % dimensions of result matrix A
    A_z = N2+1; % rows
    A_s = N1;   % columns
    % dimensions of extended G matrix
    Gext_z = N2+z;
    Gext_s = N1+s-1;
   otherwise
    error('given direction not supported.')
  end 
    
  %%% dimensions of each Toeplitz block
  %%%B_z = A_z;
  %%%B_s = Gext_z;
  %%% block dimension of the blockmatrix
  %%%BB_z = A_s;
  %%%BB_s = Gext_s;
  % size of circulant block
  bw_block_l = 0;
  bw_block_u = z-1;
  l = max(A_z+bw_block_u, Gext_z+bw_block_l);
  % block size of the circulant block matrix
  bw_blockmatrix_l = 0;
  bw_blockmatrix_u = s-1;
  L = max(A_s+bw_blockmatrix_u, Gext_s+bw_blockmatrix_l);
  % Matrix of first column of each circulant block in the
  % block-circulant matrix (dimension l times L)
  vi_x1 = zeros(l,L);
  vi_x1(1,1) = nonlocal.Wx1(1,1);
  vi_x1(end:-1:(end-z+2),1) = nonlocal.Wx1(2:end,1);
  vi_x1(1,(end-s+2):1:end) = nonlocal.Wx1(1,end:-1:2);
  vi_x1(  end:-1:(end-z+2),(end-s+2):1:end) = nonlocal.Wx1(2:end,end:-1:2);
  vi_x2 = zeros(l,L);
  vi_x2(1,1) = nonlocal.Wx2(1,1);
  vi_x2(end:-1:(end-z+2),1) = nonlocal.Wx2(2:end,1);
  vi_x2(1,(end-s+2):1:end) = nonlocal.Wx2(1,end:-1:2);
  vi_x2(  end:-1:(end-z+2),(end-s+2):1:end) = nonlocal.Wx2(2:end,end:-1:2);
  
  nonlocalBCs.A_z = A_z;
  nonlocalBCs.A_s = A_s;
  nonlocalBCs.Gext_z = Gext_z;
  nonlocalBCs.Gext_s = Gext_s;
  nonlocalBCs.l = l;
  nonlocalBCs.L = L;
  nonlocalBCs.vi_x1 = vi_x1;
  nonlocalBCs.vi_x1_fft2 = fft2(vi_x1);
  nonlocalBCs.vi_x2 = vi_x2;
  nonlocalBCs.vi_x2_fft2 = fft2(vi_x2);

 otherwise
  error('BC type not yet implemented.')
end

return % end of function
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function ret = setupMvFFT(W, N1, N2, lm, km)
% res = x(W, N1, N2, lm, km)
%
% This function sets up the data required for an FFT based evaluation of a
% matrix-vector product V*g with the matrix V generated by the weight
% matrix W. 
%
% The weight matrix W is assumed to be centred around (km+1, lm+1) and all
% weights outside of W are zero.
% The matrix V is an N1 times N1 block-circulant matrix with circulant
% blocks of dimension N2 times N2. 
%
% Returned is a data structure containing the data for the
% application of evalIntegral2D.m .
%

% Construct the 1st columns of the circulant matrices V_i (i=1:N1) in the 
% columns of matrix vi and compute their FFT in viFFT
vi = zeros(N2, N1);                       % pre-allocate with zeros
vi(1:size(W,1), 1:size(W,2)) = W;         % place W in upper left corner
vi = vi([km+1:end 1:km],[lm+1:end 1:lm]); % rotate the center of W into the
                                          % (1,1) position of vi
					  % vi(:) is now the 1st row of V
vi = vi([1 end:-1:2], [1 end:-1:2]);      % reorder such that vi(:,i) is
                                          % the 1st column of matrix V_i
					  
% for fast computation using fft and fft2
viFFT  = fft(vi);
viFFT2 = fft2(vi);

% construct return data structure
ret.N1        = N1;
ret.N2        = N2;
ret.viFFT     = viFFT;
ret.viFFT2    = viFFT2;

return; % end of function
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
